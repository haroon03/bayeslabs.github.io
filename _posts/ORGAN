<b>Objective-Reinforced Generative Adversarial Network (ORGAN)</b> is a modified version of a basic Generative Adversarial Network (GAN). 
Before we dig deep into theory and implementation of ORGAN let me brief you about the basics of GAN.
A simple GAN is composed of two neural networks, The Generator and The Discriminator. 
(i). Generator: The main aim of the Generator is to produce/generate fake samples which resemble the true data/distribution so closely,
that the discriminator cannot differentiate between the true data and the fake ones, in other words, it tries to fool the discriminator.
(ii). Discriminator: The Discriminator(D), as the name suggests discriminates the input data and classifies whether it is from the true
data sample/distribution or is a fake sample generated by the Generator(G). The Discriminator is initially trained on true labeled data 
samples.

Both of these networks work against each other trying to be better at their job by proving the other wrong. Their main objective is to 
produce data points that are similar to some data points in the training data.An ORGAN takes into account the domain-specific desired 
objectives defined. This is achieved by using a reward function for each generated molecule. 

Components that make an ORGAN:
Generator(G): It is a Recurrent Neural Network(RNN) with Long-short Term Memory (LSTM) cells. It is responsible for generating molecules 
that closely follows the distribution of training data. A generator can be assumed as a money forger. The Generator is initially trained 
on the training set using Maximum Likelihood Estimation(MLE) to generate molecules.

```python
class Generator(nn.Module):
    def __init__(self, embedding_layer, hidden_size, num_layers, dropout):
        super(Generator, self).__init__()

        self.embedding_layer = embedding_layer
        self.lstm_layer = nn.LSTM(embedding_layer.embedding_dim,
                                  hidden_size, num_layers,
                                  batch_first=True, dropout=dropout)
        self.linear_layer = nn.Linear(hidden_size,
                                      embedding_layer.num_embeddings)

    def forward(self, x, lengths, states=None):
        x = self.embedding_layer(x)
        x = pack_padded_sequence(x, lengths, batch_first=True)
        x, states = self.lstm_layer(x, states)
        x, _ = pad_packed_sequence(x, batch_first=True)
        x = self.linear_layer(x)

        return x, lengths, states
```

Discriminator(D): It plays the role of a cop who is trained to catch fake molecules generated by G.The Discriminator is composed of 
Convolutional Neural Networks(CNN), specifically designed for text classification. It gives a probability estimation of the molecule of 
either being fake(0/generated) or real(1/belongs to true/training data). 
```python
class Discriminator(nn.Module):
    def __init__(self, desc_embedding_layer, convs, dropout=0):
        super(Discriminator, self).__init__()

        self.embedding_layer = desc_embedding_layer
        self.conv_layers = nn.ModuleList(
            [nn.Conv2d(1, f, kernel_size=(
                n, self.embedding_layer.embedding_dim)
                       ) for f, n in convs])
        sum_filters = sum([f for f, _ in convs])
        self.highway_layer = nn.Linear(sum_filters, sum_filters)
        self.dropout_layer = nn.Dropout(p=dropout)
        self.output_layer = nn.Linear(sum_filters, 1)

    def forward(self, x):
        x = self.embedding_layer(x)
        x = x.unsqueeze(1)
        convs = [F.elu(conv_layer(x)).squeeze(3)
                 for conv_layer in self.conv_layers]
        x = [F.max_pool1d(c, c.shape[2]).squeeze(2) for c in convs]
        x = torch.cat(x, dim=1)

        h = self.highway_layer(x)
        t = torch.sigmoid(h)
        x = t * F.elu(h) + (1 - t) * x
        x = self.dropout_layer(x)
        out = self.output_layer(x)

        return out

```

Reinforcement Metric: Molecular metrics are implemented using the RDKit chem-informatics package. Metrics include Synthesis Accessibility, 
Natural Product likeliness, Drug-likeness, LogP. These were applied to calculate the reward for each generated molecule. Reinforcement 
provides a quality metric (between 0 & 1) which gives the desirability of a specific molecule, where 1 being highly desirable and 0 being 
highly undesirable.

The main objective of the reinforcement metric is to maximize the reward by optimizing the generator to generate molecules similar to the 
initial distribution of data. The molecules generates are then analyzed by the discriminator and the reward metric, which then optimize or 
train the generator to fool the discriminator.
Both the generator and discriminator act as adversaries for each other, the main idea is that two different neural networks play a game 
against each other: given an initial training distribution p(data), the generator G samples x from a distribution p(synth) generated with 
random noise z, while a discriminator D looks at samples, either from p(syntetic) or from p(data), and tries to classify their identity (y)
as either real x∈p(data) or fake x∈p(synth).
Dataset: ChEMBL SMILES dataset has been used for the training purpose of the GAN. SMILES is a line notation for representing molecules 
and reactions.

min G max D Ex∼p(data)(x)[logD(x)] +Ez∼p(synthetic)(z)[log(1−D(G(z)))]

